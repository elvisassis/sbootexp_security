package br.com.elvisassis.sbootexp_secutiry.domain.service;import br.com.elvisassis.sbootexp_secutiry.domain.dto.AuthRequestDTO;import br.com.elvisassis.sbootexp_secutiry.domain.dto.TokenDTO;import br.com.elvisassis.sbootexp_secutiry.domain.entity.User;import br.com.elvisassis.sbootexp_secutiry.domain.repository.UserPermissionRepository;import br.com.elvisassis.sbootexp_secutiry.domain.repository.UserRepository;import br.com.elvisassis.sbootexp_secutiry.domain.security.utils.JwtTokenProvider;import br.com.elvisassis.sbootexp_secutiry.exception.RequiredObjectIsNullException;import br.com.elvisassis.sbootexp_secutiry.mapper.UserMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.http.ResponseEntity;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.DelegatingPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;import org.springframework.stereotype.Service;import java.util.HashMap;import java.util.Map;@Slf4j@Servicepublic class AuthService {    public AuthService(AuthenticationManager authenticationManager, JwtTokenProvider tokenProvider, UserRepository repository, UserPermissionRepository userPermissionRepository) {        this.authenticationManager = authenticationManager;        this.tokenProvider = tokenProvider;        this.repository = repository;        this.userPermissionRepository = userPermissionRepository;    }    private final AuthenticationManager authenticationManager;    private final JwtTokenProvider tokenProvider;    private final UserRepository repository;    private final UserPermissionRepository userPermissionRepository;    public TokenDTO sigIn(AuthRequestDTO credentials) {        var user = repository.findByUsername(credentials.getUsername())                .orElseThrow(() -> new UsernameNotFoundException("Username " + credentials.getUsername() + " not found"));        var token = tokenProvider.createAccessToken(                credentials.getUsername(),                user.getRoles()        );        return token;    }    public ResponseEntity<TokenDTO> refreshToken(String username, String refreshToken) {        var user = repository.findByUsername(username)                .orElseThrow(() -> new UsernameNotFoundException("Username " + username + " not found"));        TokenDTO token = tokenProvider.refreshToken(refreshToken);        return ResponseEntity.ok(token);    }    public AuthRequestDTO create(AuthRequestDTO user) {        if (user == null) throw new RequiredObjectIsNullException();        log.info("Creating one new User!");        User entity = UserMapper.authRequestDTOUser(user, generateHashedPassword(user.getPassword()));        return UserMapper.userToAuthRequestDTO(repository.save(entity));    }    private String generateHashedPassword(String password) {        PasswordEncoder pbkdf2Encoder = new Pbkdf2PasswordEncoder(                "", 8, 185000,                Pbkdf2PasswordEncoder.SecretKeyFactoryAlgorithm.PBKDF2WithHmacSHA256);        Map<String, PasswordEncoder> encoders = new HashMap<>();        encoders.put("pbkdf2", pbkdf2Encoder);        DelegatingPasswordEncoder passwordEncoder = new DelegatingPasswordEncoder("pbkdf2", encoders);        passwordEncoder.setDefaultPasswordEncoderForMatches(pbkdf2Encoder);        return passwordEncoder.encode(password);    }}